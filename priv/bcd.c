/* bcd.c
 *
 * Deciphering BCD arithmetic on the RCA CDP1804/5/6 family.
 *
 * Documentation is scarce, but it turns out that the 32-bit x86 add;daa and sub;das
 * match the CDP1805 on published test vectors that include some invalid BCD inputs.
 * Therefore, 32-bit x86 add;daa and sub;das are used as the source of truth, and
 * software models are evaluated against them.
 *
 * This should ideally be compiled to 32-bit x86 code. If so, the x86 code becomes the
 * reference against which all software models are evaluated. If not, the "mikpe"
 * software models, which are known to match x86, become the reference.
 *
 * Currently only one CDP1804/5/6 emulator matches published test vectors, and no emulator
 * matches on exhaustive tests.
 */

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

/* test vectors from 1805 hardware */

struct tvector {
    uint8_t y;		/* subtrahend for -, addend for + */
    struct {
	uint8_t d;	/* result in the D register (accumulator) */
	uint8_t df;	/* result in the data flag register: carry for +, inverted borrow for - */
    } rs[16];		/* 0-15: minuend for -, addend for + */
};

static const struct tvector dadd_vectors[] = {
    /* from 1805 hardware, https://groups.io/g/cosmacelf/message/38834 */
    { 0x00, {{0x00,0},{0x01,0},{0x02,0},{0x03,0},{0x04,0},{0x05,0},{0x06,0},{0x07,0},{0x08,0},{0x09,0},{0x10,0},{0x11,0},{0x12,0},{0x13,0},{0x14,0},{0x15,0}}},
    { 0x01, {{0x01,0},{0x02,0},{0x03,0},{0x04,0},{0x05,0},{0x06,0},{0x07,0},{0x08,0},{0x09,0},{0x10,0},{0x11,0},{0x12,0},{0x13,0},{0x14,0},{0x15,0},{0x16,0}}},
    { 0x02, {{0x02,0},{0x03,0},{0x04,0},{0x05,0},{0x06,0},{0x07,0},{0x08,0},{0x09,0},{0x10,0},{0x11,0},{0x12,0},{0x13,0},{0x14,0},{0x15,0},{0x16,0},{0x17,0}}},
    { 0x03, {{0x03,0},{0x04,0},{0x05,0},{0x06,0},{0x07,0},{0x08,0},{0x09,0},{0x10,0},{0x11,0},{0x12,0},{0x13,0},{0x14,0},{0x15,0},{0x16,0},{0x17,0},{0x18,0}}},
    { 0x04, {{0x04,0},{0x05,0},{0x06,0},{0x07,0},{0x08,0},{0x09,0},{0x10,0},{0x11,0},{0x12,0},{0x13,0},{0x14,0},{0x15,0},{0x16,0},{0x17,0},{0x18,0},{0x19,0}}},
    { 0x05, {{0x05,0},{0x06,0},{0x07,0},{0x08,0},{0x09,0},{0x10,0},{0x11,0},{0x12,0},{0x13,0},{0x14,0},{0x15,0},{0x16,0},{0x17,0},{0x18,0},{0x19,0},{0x1A,0}}},
    { 0x06, {{0x06,0},{0x07,0},{0x08,0},{0x09,0},{0x10,0},{0x11,0},{0x12,0},{0x13,0},{0x14,0},{0x15,0},{0x16,0},{0x17,0},{0x18,0},{0x19,0},{0x1A,0},{0x1B,0}}},
    { 0x07, {{0x07,0},{0x08,0},{0x09,0},{0x10,0},{0x11,0},{0x12,0},{0x13,0},{0x14,0},{0x15,0},{0x16,0},{0x17,0},{0x18,0},{0x19,0},{0x1A,0},{0x1B,0},{0x1C,0}}},
    { 0x08, {{0x08,0},{0x09,0},{0x10,0},{0x11,0},{0x12,0},{0x13,0},{0x14,0},{0x15,0},{0x16,0},{0x17,0},{0x18,0},{0x19,0},{0x1A,0},{0x1B,0},{0x1C,0},{0x1D,0}}},
    { 0x09, {{0x09,0},{0x10,0},{0x11,0},{0x12,0},{0x13,0},{0x14,0},{0x15,0},{0x16,0},{0x17,0},{0x18,0},{0x19,0},{0x1A,0},{0x1B,0},{0x1C,0},{0x1D,0},{0x1E,0}}},
    { 0x0A, {{0x10,0},{0x11,0},{0x12,0},{0x13,0},{0x14,0},{0x15,0},{0x16,0},{0x17,0},{0x18,0},{0x19,0},{0x1A,0},{0x1B,0},{0x1C,0},{0x1D,0},{0x1E,0},{0x1F,0}}},
    { 0x0B, {{0x11,0},{0x12,0},{0x13,0},{0x14,0},{0x15,0},{0x16,0},{0x17,0},{0x18,0},{0x19,0},{0x1A,0},{0x1B,0},{0x1C,0},{0x1D,0},{0x1E,0},{0x1F,0},{0x20,0}}},
    { 0x0C, {{0x12,0},{0x13,0},{0x14,0},{0x15,0},{0x16,0},{0x17,0},{0x18,0},{0x19,0},{0x1A,0},{0x1B,0},{0x1C,0},{0x1D,0},{0x1E,0},{0x1F,0},{0x20,0},{0x21,0}}},
    { 0x0D, {{0x13,0},{0x14,0},{0x15,0},{0x16,0},{0x17,0},{0x18,0},{0x19,0},{0x1A,0},{0x1B,0},{0x1C,0},{0x1D,0},{0x1E,0},{0x1F,0},{0x20,0},{0x21,0},{0x22,0}}},
    { 0x0E, {{0x14,0},{0x15,0},{0x16,0},{0x17,0},{0x18,0},{0x19,0},{0x1A,0},{0x1B,0},{0x1C,0},{0x1D,0},{0x1E,0},{0x1F,0},{0x20,0},{0x21,0},{0x22,0},{0x23,0}}},
    { 0x0F, {{0x15,0},{0x16,0},{0x17,0},{0x18,0},{0x19,0},{0x1A,0},{0x1B,0},{0x1C,0},{0x1D,0},{0x1E,0},{0x1F,0},{0x20,0},{0x21,0},{0x22,0},{0x23,0},{0x24,0}}},

    /* from 1805 hardware, from https://groups.io/g/cosmacelf/message/38835 */
    { 0x10, {{0x10,0},{0x11,0},{0x12,0},{0x13,0},{0x14,0},{0x15,0},{0x16,0},{0x17,0},{0x18,0},{0x19,0},{0x20,0},{0x21,0},{0x22,0},{0x23,0},{0x24,0},{0x25,0}}},
    { 0x20, {{0x20,0},{0x21,0},{0x22,0},{0x23,0},{0x24,0},{0x25,0},{0x26,0},{0x27,0},{0x28,0},{0x29,0},{0x30,0},{0x31,0},{0x32,0},{0x33,0},{0x34,0},{0x35,0}}},
    { 0x30, {{0x30,0},{0x31,0},{0x32,0},{0x33,0},{0x34,0},{0x35,0},{0x36,0},{0x37,0},{0x38,0},{0x39,0},{0x40,0},{0x41,0},{0x42,0},{0x43,0},{0x44,0},{0x45,0}}},
    { 0x40, {{0x40,0},{0x41,0},{0x42,0},{0x43,0},{0x44,0},{0x45,0},{0x46,0},{0x47,0},{0x48,0},{0x49,0},{0x50,0},{0x51,0},{0x52,0},{0x53,0},{0x54,0},{0x55,0}}},
    { 0x50, {{0x50,0},{0x51,0},{0x52,0},{0x53,0},{0x54,0},{0x55,0},{0x56,0},{0x57,0},{0x58,0},{0x59,0},{0x60,0},{0x61,0},{0x62,0},{0x63,0},{0x64,0},{0x65,0}}},
    { 0x60, {{0x60,0},{0x61,0},{0x62,0},{0x63,0},{0x64,0},{0x65,0},{0x66,0},{0x67,0},{0x68,0},{0x69,0},{0x70,0},{0x71,0},{0x72,0},{0x73,0},{0x74,0},{0x75,0}}},
    { 0x70, {{0x70,0},{0x71,0},{0x72,0},{0x73,0},{0x74,0},{0x75,0},{0x76,0},{0x77,0},{0x78,0},{0x79,0},{0x80,0},{0x81,0},{0x82,0},{0x83,0},{0x84,0},{0x85,0}}},
    { 0x80, {{0x80,0},{0x81,0},{0x82,0},{0x83,0},{0x84,0},{0x85,0},{0x86,0},{0x87,0},{0x88,0},{0x89,0},{0x90,0},{0x91,0},{0x92,0},{0x93,0},{0x94,0},{0x95,0}}},
    { 0x90, {{0x90,0},{0x91,0},{0x92,0},{0x93,0},{0x94,0},{0x95,0},{0x96,0},{0x97,0},{0x98,0},{0x99,0},{0x00,1},{0x01,1},{0x02,1},{0x03,1},{0x04,1},{0x05,1}}},
    { 0xA0, {{0x00,1},{0x01,1},{0x02,1},{0x03,1},{0x04,1},{0x05,1},{0x06,1},{0x07,1},{0x08,1},{0x09,1},{0x10,1},{0x11,1},{0x12,1},{0x13,1},{0x14,1},{0x15,1}}},
    { 0xB0, {{0x10,1},{0x11,1},{0x12,1},{0x13,1},{0x14,1},{0x15,1},{0x16,1},{0x17,1},{0x18,1},{0x19,1},{0x20,1},{0x21,1},{0x22,1},{0x23,1},{0x24,1},{0x25,1}}},
    { 0xC0, {{0x20,1},{0x21,1},{0x22,1},{0x23,1},{0x24,1},{0x25,1},{0x26,1},{0x27,1},{0x28,1},{0x29,1},{0x30,1},{0x31,1},{0x32,1},{0x33,1},{0x34,1},{0x35,1}}},
    { 0xD0, {{0x30,1},{0x31,1},{0x32,1},{0x33,1},{0x34,1},{0x35,1},{0x36,1},{0x37,1},{0x38,1},{0x39,1},{0x40,1},{0x41,1},{0x42,1},{0x43,1},{0x44,1},{0x45,1}}},
    { 0xE0, {{0x40,1},{0x41,1},{0x42,1},{0x43,1},{0x44,1},{0x45,1},{0x46,1},{0x47,1},{0x48,1},{0x49,1},{0x50,1},{0x51,1},{0x52,1},{0x53,1},{0x54,1},{0x55,1}}},
    { 0xF0, {{0x50,1},{0x51,1},{0x52,1},{0x53,1},{0x54,1},{0x55,1},{0x56,1},{0x57,1},{0x58,1},{0x59,1},{0x60,1},{0x61,1},{0x62,1},{0x63,1},{0x64,1},{0x65,1}}},
};

static const struct tvector dsub_vectors[] = {
    /* from 1805 hardware, https://groups.io/g/cosmacelf/message/38848 */
    { 0x00, {{0x00,1},{0x01,1},{0x02,1},{0x03,1},{0x04,1},{0x05,1},{0x06,1},{0x07,1},{0x08,1},{0x09,1},{0x04,1},{0x05,1},{0x06,1},{0x07,1},{0x08,1},{0x09,1}}},
    { 0x01, {{0x99,0},{0x00,1},{0x01,1},{0x02,1},{0x03,1},{0x04,1},{0x05,1},{0x06,1},{0x07,1},{0x08,1},{0x09,1},{0x04,1},{0x05,1},{0x06,1},{0x07,1},{0x08,1}}},
    { 0x02, {{0x98,0},{0x99,0},{0x00,1},{0x01,1},{0x02,1},{0x03,1},{0x04,1},{0x05,1},{0x06,1},{0x07,1},{0x08,1},{0x09,1},{0x04,1},{0x05,1},{0x06,1},{0x07,1}}},
    { 0x03, {{0x97,0},{0x98,0},{0x99,0},{0x00,1},{0x01,1},{0x02,1},{0x03,1},{0x04,1},{0x05,1},{0x06,1},{0x07,1},{0x08,1},{0x09,1},{0x04,1},{0x05,1},{0x06,1}}},
    { 0x04, {{0x96,0},{0x97,0},{0x98,0},{0x99,0},{0x00,1},{0x01,1},{0x02,1},{0x03,1},{0x04,1},{0x05,1},{0x06,1},{0x07,1},{0x08,1},{0x09,1},{0x04,1},{0x05,1}}},
    { 0x05, {{0x95,0},{0x96,0},{0x97,0},{0x98,0},{0x99,0},{0x00,1},{0x01,1},{0x02,1},{0x03,1},{0x04,1},{0x05,1},{0x06,1},{0x07,1},{0x08,1},{0x09,1},{0x04,1}}},
    { 0x06, {{0x94,0},{0x95,0},{0x96,0},{0x97,0},{0x98,0},{0x99,0},{0x00,1},{0x01,1},{0x02,1},{0x03,1},{0x04,1},{0x05,1},{0x06,1},{0x07,1},{0x08,1},{0x09,1}}},
    { 0x07, {{0x93,0},{0x94,0},{0x95,0},{0x96,0},{0x97,0},{0x98,0},{0x99,0},{0x00,1},{0x01,1},{0x02,1},{0x03,1},{0x04,1},{0x05,1},{0x06,1},{0x07,1},{0x08,1}}},
    { 0x08, {{0x92,0},{0x93,0},{0x94,0},{0x95,0},{0x96,0},{0x97,0},{0x98,0},{0x99,0},{0x00,1},{0x01,1},{0x02,1},{0x03,1},{0x04,1},{0x05,1},{0x06,1},{0x07,1}}},
    { 0x09, {{0x91,0},{0x92,0},{0x93,0},{0x94,0},{0x95,0},{0x96,0},{0x97,0},{0x98,0},{0x99,0},{0x00,1},{0x01,1},{0x02,1},{0x03,1},{0x04,1},{0x05,1},{0x06,1}}},
    { 0x0A, {{0x90,0},{0x91,0},{0x92,0},{0x93,0},{0x94,0},{0x95,0},{0x96,0},{0x97,0},{0x98,0},{0x99,0},{0x00,1},{0x01,1},{0x02,1},{0x03,1},{0x04,1},{0x05,1}}},
    { 0x0B, {{0x8F,0},{0x90,0},{0x91,0},{0x92,0},{0x93,0},{0x94,0},{0x95,0},{0x96,0},{0x97,0},{0x98,0},{0x99,0},{0x00,1},{0x01,1},{0x02,1},{0x03,1},{0x04,1}}},
    { 0x0C, {{0x8E,0},{0x8F,0},{0x90,0},{0x91,0},{0x92,0},{0x93,0},{0x94,0},{0x95,0},{0x96,0},{0x97,0},{0x98,0},{0x99,0},{0x00,1},{0x01,1},{0x02,1},{0x03,1}}},
    { 0x0D, {{0x8D,0},{0x8E,0},{0x8F,0},{0x90,0},{0x91,0},{0x92,0},{0x93,0},{0x94,0},{0x95,0},{0x96,0},{0x97,0},{0x98,0},{0x99,0},{0x00,1},{0x01,1},{0x02,1}}},
    { 0x0E, {{0x8C,0},{0x8D,0},{0x8E,0},{0x8F,0},{0x90,0},{0x91,0},{0x92,0},{0x93,0},{0x94,0},{0x95,0},{0x96,0},{0x97,0},{0x98,0},{0x99,0},{0x00,1},{0x01,1}}},
    { 0x0F, {{0x8B,0},{0x8C,0},{0x8D,0},{0x8E,0},{0x8F,0},{0x90,0},{0x91,0},{0x92,0},{0x93,0},{0x94,0},{0x95,0},{0x96,0},{0x97,0},{0x98,0},{0x99,0},{0x00,1}}},
    { 0x00, {{0x00,1},{0x01,1},{0x02,1},{0x03,1},{0x04,1},{0x05,1},{0x06,1},{0x07,1},{0x08,1},{0x09,1},{0x04,1},{0x05,1},{0x06,1},{0x07,1},{0x08,1},{0x09,1}}},
    { 0x10, {{0x90,0},{0x91,0},{0x92,0},{0x93,0},{0x94,0},{0x95,0},{0x96,0},{0x97,0},{0x98,0},{0x99,0},{0x94,0},{0x95,0},{0x96,0},{0x97,0},{0x98,0},{0x99,0}}},
    { 0x20, {{0x80,0},{0x81,0},{0x82,0},{0x83,0},{0x84,0},{0x85,0},{0x86,0},{0x87,0},{0x88,0},{0x89,0},{0x84,0},{0x85,0},{0x86,0},{0x87,0},{0x88,0},{0x89,0}}},
    { 0x30, {{0x70,0},{0x71,0},{0x72,0},{0x73,0},{0x74,0},{0x75,0},{0x76,0},{0x77,0},{0x78,0},{0x79,0},{0x74,0},{0x75,0},{0x76,0},{0x77,0},{0x78,0},{0x79,0}}},
    { 0x40, {{0x60,0},{0x61,0},{0x62,0},{0x63,0},{0x64,0},{0x65,0},{0x66,0},{0x67,0},{0x68,0},{0x69,0},{0x64,0},{0x65,0},{0x66,0},{0x67,0},{0x68,0},{0x69,0}}},
    { 0x50, {{0x50,0},{0x51,0},{0x52,0},{0x53,0},{0x54,0},{0x55,0},{0x56,0},{0x57,0},{0x58,0},{0x59,0},{0x54,0},{0x55,0},{0x56,0},{0x57,0},{0x58,0},{0x59,0}}},
    { 0x60, {{0x40,0},{0x41,0},{0x42,0},{0x43,0},{0x44,0},{0x45,0},{0x46,0},{0x47,0},{0x48,0},{0x49,0},{0x44,0},{0x45,0},{0x46,0},{0x47,0},{0x48,0},{0x49,0}}},
    { 0x70, {{0x30,0},{0x31,0},{0x32,0},{0x33,0},{0x34,0},{0x35,0},{0x36,0},{0x37,0},{0x38,0},{0x39,0},{0x34,0},{0x35,0},{0x36,0},{0x37,0},{0x38,0},{0x39,0}}},
    { 0x80, {{0x20,0},{0x21,0},{0x22,0},{0x23,0},{0x24,0},{0x25,0},{0x26,0},{0x27,0},{0x28,0},{0x29,0},{0x24,0},{0x25,0},{0x26,0},{0x27,0},{0x28,0},{0x29,0}}},
    { 0x90, {{0x10,0},{0x11,0},{0x12,0},{0x13,0},{0x14,0},{0x15,0},{0x16,0},{0x17,0},{0x18,0},{0x19,0},{0x14,0},{0x15,0},{0x16,0},{0x17,0},{0x18,0},{0x19,0}}},
    { 0xA0, {{0x00,0},{0x01,0},{0x02,0},{0x03,0},{0x04,0},{0x05,0},{0x06,0},{0x07,0},{0x08,0},{0x09,0},{0x04,0},{0x05,0},{0x06,0},{0x07,0},{0x08,0},{0x09,0}}},
    { 0xB0, {{0xF0,0},{0xF1,0},{0xF2,0},{0xF3,0},{0xF4,0},{0xF5,0},{0xF6,0},{0xF7,0},{0xF8,0},{0xF9,0},{0xF4,0},{0xF5,0},{0xF6,0},{0xF7,0},{0xF8,0},{0xF9,0}}},
    { 0xC0, {{0xE0,0},{0xE1,0},{0xE2,0},{0xE3,0},{0xE4,0},{0xE5,0},{0xE6,0},{0xE7,0},{0xE8,0},{0xE9,0},{0xE4,0},{0xE5,0},{0xE6,0},{0xE7,0},{0xE8,0},{0xE9,0}}},
    { 0xD0, {{0xD0,0},{0xD1,0},{0xD2,0},{0xD3,0},{0xD4,0},{0xD5,0},{0xD6,0},{0xD7,0},{0xD8,0},{0xD9,0},{0xD4,0},{0xD5,0},{0xD6,0},{0xD7,0},{0xD8,0},{0xD9,0}}},
    { 0xE0, {{0xC0,0},{0xC1,0},{0xC2,0},{0xC3,0},{0xC4,0},{0xC5,0},{0xC6,0},{0xC7,0},{0xC8,0},{0xC9,0},{0xC4,0},{0xC5,0},{0xC6,0},{0xC7,0},{0xC8,0},{0xC9,0}}},
    { 0xF0, {{0xB0,0},{0xB1,0},{0xB2,0},{0xB3,0},{0xB4,0},{0xB5,0},{0xB6,0},{0xB7,0},{0xB8,0},{0xB9,0},{0xB4,0},{0xB5,0},{0xB6,0},{0xB7,0},{0xB8,0},{0xB9,0}}},
};

/* Special vectors from the manuals:
 * 0x99 - 0x88 = 0x11 with DF=1 (true positive number)
 * 0x88 - 0x99 = 0x89 with DF=0 (negative number in ten's complement)
 */

struct params {
    uint8_t a;	/* minuend for -, addend for + */
    uint8_t b;	/* subtrahend for -, addend for + */
    uint8_t d;	/* result in D */
    uint8_t df;	/* result in DF */
};

#ifdef __i386__
/*
 * x86 BCD add/sub
 */

unsigned char the_a;
unsigned char the_b;
unsigned char the_c;

extern void bcdadd_asm(void);
asm(
    "	.text\n"
    "	.globl bcdadd_asm\n"
    "	.type bcdadd_asm,@function\n"
    "bcdadd_asm:\n"
    "	clc\n"
    "	movb the_a, %al\n"
    "	add the_b, %al\n"
    "	daa\n"
    "	movb %al, the_a\n"
    "	setc the_c\n"
    "	ret\n"
    "	.size bcdadd_asm,.-bcdadd_asm");

extern void bcdsub_asm(void);
asm(
    "	.text\n"
    "	.globl bcdsub_asm\n"
    "	.type bcdsub_asm,@function\n"
    "bcdsub_asm:\n"
    "	clc\n"
    "	movb the_a, %al\n"
    "	sub the_b, %al\n"
    "	das\n"
    "	movb %al, the_a\n"
    "	setc the_c\n"
    "	ret\n"
    "	.size bcdsub_asm,.-bcdsub_asm");

/* works for all known test vectors */
void bcdadd_x86(struct params *params)
{
    the_a = params->a;
    the_b = params->b;
    bcdadd_asm();
    params->d = the_a;
    params->df = the_c;
}

/* works for all known test vectors */
void bcdsub_x86(struct params *params)
{
    the_a = params->a;	/* minuend */
    the_b = params->b;	/* subtrahend */
    bcdsub_asm();
    params->d = the_a;
    params->df = the_c ^ 1;	/* map x86 carry to CDP1804 borrow */
}
#endif	/* __i386__ */

/* works for all known 1805 test vectors, and matches x86 on exhaustive tests
 * see also http://www.righto.com/2023/01/understanding-x86s-decimal-adjust-after.html
 */
void bcdadd_mikpe(struct params *params)
{
    unsigned int word;	/* must be wider than a byte */

    /* Plain binary addition. */
    word = params->a + params->b;

    /* The low digit is corrected if it exceeds 9 or if the binary addition
     * sets the auxiliary flag (aka half-carry).
     */
    if ((word & 0x0F) > 0x09 || (word & 0x0F) < (params->a & 0x0F)) {
	word += 0x06;
    }
    /* The high digit is corrected if it exceeds 9 or if binary addition
     * sets the carry flag. The check is (word & 0xFF) > 0x9F || CF, but
     * CF is word & 0x100, so the check reduces to word > 0x9F.
     */
    if (word > 0x9F) {
	word += 0x60;
	params->df = 1;
    } else
	params->df = 0;
    params->d = word & 0xFF;
}

/* works for all known test vectors, and matches x86 on exhaustive tests
 * see c.f. https://github.com/86Box/86Box/blob/master/src/cpu/x86_ops_bcd.h
 */
void bcdsub_mikpe(struct params *params)
{
    unsigned int word;		/* must be wider than a byte */
    uint8_t AL, old_AL;
    bool AF, CF, old_CF;

    word = params->a - params->b;
    CF = (word & 0x100) != 0;
    AF = (word & 0x0F) > (params->a & 0x0F);
    AL = word & 0xFF;

    old_AL = AL;
    old_CF = CF;
    CF = 0;

    if ((AL & 0x0F) > 9 || AF) {
	unsigned int temp = (unsigned int)AL - 0x06;
	AL = temp & 0xFF;		/* AL -= 6 */
	if (old_CF || (temp & 0x100))	/* borrow from AL - 6 */
	    CF = 1;
    }

    if (old_AL > 0x99 || old_CF) {
	AL -= 0x60;
	CF = 1;
    }

    params->df = !CF;
    params->d = AL;
}

/* From Marcel van Tongeren's emma_02 emulator:
 * https://github.com/etxmato/emma_02/blob/master/src/cdp1802.cpp
 * (supposedly based on Run02 or some earlier version)
 */
/* works for all known test vectors, but doesn't match x86 on exhaustive tests */
void bcdadd_emma02(struct params *params)
{
    unsigned int tempWord;	/* must be wider than uint8_t */

    /* cycle 1 */
    tempWord = params->a + params->b;
    params->df = (tempWord >> 8) & 1;
    params->d = tempWord & 255;

    /* cycle 2 */
    if ((tempWord & 0x0f) > 0x09 || (tempWord & 0x0f) < (params->a & 0x0f))
	tempWord += 0x06;
    if ((tempWord & 0xf0) > 0x90 || (tempWord & 0x100) == 0x100) {
	params->df = 1;
	tempWord += 0x60;
    }
    params->d = tempWord & 255;
}

/* From Mike Riley's Run02 emulator:
 * https://github.com/rileym65/Run02/blob/main/cpu.c
 */
/* does not work for all known test vectors, e.g. 0x0A+0xF0 becomes D=0x00 DF=0 instead of D=0x60 DF=1 */
void bcdadd_Run02(struct params *params)
{
    params->d = params->a + params->b;
    params->df = 0;
    if ((params->d & 0x0f) >= 0x0a || (params->d & 0x0f) < (params->a & 0x0f))
	params->d += 0x06;
    if ((params->d & 0xf0) >= 0xa0 || (params->d & 0xf0) < (params->a & 0xf0)) {
	params->d += 0x60;
	params->df = 1;
    }
    if ((params->d & 0xf0) < (params->a & 0xf0))
	params->df = 1;
}

/* From Mark Clegg's EM1802 emulator:
 * https://github.com/Mark-Clegg/EM1802/blob/master/processor_bcd.cpp
 */
/* fails on test vectors involving invalid BCD input */
void bcdadd_EM1802(struct params *params)
{
    int A = (params->a >> 4) * 10 + (params->a & 0x0F);
    int B = (params->b >> 4) * 10 + (params->b & 0x0F);
    int temp = A + B;
    params->df = (temp > 99);
    params->d = ((((temp & 0xFF) / 10) % 10) << 4) + (temp % 10);
}

uint8_t tobcd_alan(uint8_t r)
{
    return ((r / 10) << 4) + (r % 10);
}

uint8_t frombcd_alan(uint8_t r)
{
    return ((r & 0xF0) >> 4) * 10 + (r & 0x0F);
}

/* From Alan Cox' 1802 emulator:
 * https://github.com/EtchedPixels/EmulatorKit/blob/master/1802.c
 */
/* fails on test vectors involving invalid BCD input */
void bcdadd_alan(struct params *params)
{
    uint8_t res = frombcd_alan(params->a) + frombcd_alan(params->b);
    params->df = (res > 99);
    params->d = tobcd_alan(res);
}

/* From https://homepage.cs.uiowa.edu/~jones/bcd/bcd.html. */
/* fails on test vectors involving invalid BCD input */
void bcdadd_jones(struct params *params)
{
    unsigned int t1 = params->a + 0x66;
    unsigned int t2 = t1 + params->b;
    unsigned int t3 = t1 ^ params->b;
    unsigned int t4 = t2 ^ t3;
    unsigned int t5 = ~t4 & 0x110;
    unsigned int t6 = (t5 >> 2) | (t5 >> 3);
    params->d = t2 - t6;
    params->df = (t2 >> 8) & 1;
}

struct bcdfun {
    void (*f)(struct params*);
    const char *name;
    bool broken;
};

/* the entry at index 0 is used as the reference */
static const struct bcdfun bcdadd_funs[] = {
#ifdef __i386__
    { bcdadd_x86, "bcdadd_x86", false },
#endif
    { bcdadd_mikpe, "bcdadd_mikpe", false },
    { bcdadd_emma02, "bcdadd_emma02", true },
    { bcdadd_Run02, "bcdadd_Run02", true },
    { bcdadd_EM1802, "bcdadd_EM1802", true },
    { bcdadd_alan, "bcdadd_alan", true },
    { bcdadd_jones, "bcdadd_jones", true },
};

/* the entry at index 0 is used as the reference */
static const struct bcdfun bcdsub_funs[] = {
#ifdef __i386__
    { bcdsub_x86, "bcdsub_x86", false },
#endif
    { bcdsub_mikpe, "bcdsub_mikpe", false },
};

int test_one(uint8_t a, uint8_t b, uint8_t d, uint8_t df, const struct bcdfun *bcdfun, bool verbose)
{
    struct params params;

    params.a = a;
    params.b = b;
    params.d = 0;
    params.df = 0;
    (*bcdfun->f)(&params);
    if (params.d == d && params.df == df)
	return 0;
    if (verbose)
	printf("%s(0x%02x, 0x%02x) == 0x%02x/%u != 0x%02x/%u\n",
	       bcdfun->name, params.a, params.b, params.d, params.df, d, df);
    return 1;
}

void test_vectors(const struct tvector *vectors, size_t nrvectors, const struct bcdfun *bcdfun, bool verbose)
{
    size_t i;
    unsigned int nrerr;
    unsigned int x;

    nrerr = 0;

    for (i = 0; i < nrvectors; ++i) {
	for (x = 0; x < 16; ++x) {
	    nrerr += test_one(x, vectors[i].y, vectors[i].rs[x].d, vectors[i].rs[x].df, bcdfun, verbose);
	}
    }
    if (strncmp(bcdfun->name, "bcdsub_", 7) == 0) {
	/* extra vectors from the 1806 manual */
	nrerr += test_one(0x99, 0x88, 0x11, 1, bcdfun, verbose);
	nrerr += test_one(0x88, 0x99, 0x89, 0, bcdfun, verbose);
    }

    {
	const struct bcdfun *correct;
	unsigned int a, b;
	struct params params;

	if (strncmp(bcdfun->name, "bcdsub_", 7) == 0) {
	    correct = &bcdsub_funs[0];
	} else {
	    correct = &bcdadd_funs[0];
	}

	for (a = 0; a < 256; ++a) {
	    for (b = 0; b < 256; ++b) {
		params.a = a;
		params.b = b;
		(*correct->f)(&params);
		nrerr += test_one(a, b, params.d, params.df, bcdfun, verbose);
	    }
	}
    }

    printf("%s: %u errors\n", bcdfun->name, nrerr);
}

void test_bcdfuns(const struct tvector *vectors, size_t nrvectors, const struct bcdfun *bcdfuns, size_t nrfuns, bool keep_broken, bool verbose)
{
    size_t i;

    for (i = 0; i < nrfuns; ++i) {
	if (!bcdfuns[i].broken || keep_broken)
	    test_vectors(vectors, nrvectors, &bcdfuns[i], verbose);
	else
	    printf("%s: skipped, broken\n", bcdfuns[i].name);
    }
}

#define ARRAY_SIZE(A) (sizeof((A)) / sizeof((A)[0]))

void test_bcdadd(bool keep_broken, bool verbose)
{
    test_bcdfuns(dadd_vectors, ARRAY_SIZE(dadd_vectors), bcdadd_funs, ARRAY_SIZE(bcdadd_funs), keep_broken, verbose);
}

void test_bcdsub(bool keep_broken, bool verbose)
{
    test_bcdfuns(dsub_vectors, ARRAY_SIZE(dsub_vectors), bcdsub_funs, ARRAY_SIZE(bcdsub_funs), keep_broken, verbose);
}

int main(int argc, char **argv)
{
    bool keep_broken = false;
    bool verbose = false;

    for (int i = 1; i < argc; ++i) {
	if (argv[i][0] != '-')
	    break;
	switch (argv[i][1]) {
	case 'k':
	    keep_broken = true;
	    continue;
	case 'v':
	    verbose = true;
	    continue;
	}
	break;
    }

    test_bcdadd(keep_broken, verbose);
    test_bcdsub(keep_broken, verbose);
    return 0;
}
